"""
Vulnerability Mapping Component

This module implements comprehensive vulnerability mapping capabilities including CVE integration,
configuration weakness detection, and zero-day potential assessment for MCP servers and tools.
"""

import logging
import json
import re
from typing import List, Dict, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import hashlib

from .models import (
    ToolCapabilities, EnvironmentContext, ThreatLevel, SeverityLevel,
    DifficultyLevel, CapabilityCategory, AccessLevel
)


class VulnerabilityType(Enum):
    """Types of vulnerabilities."""
    CVE_KNOWN = "cve_known"
    CONFIGURATION_WEAKNESS = "configuration_weakness"
    DESIGN_FLAW = "design_flaw"
    IMPLEMENTATION_BUG = "implementation_bug"
    ZERO_DAY_POTENTIAL = "zero_day_potential"
    MISCONFIGURATION = "misconfiguration"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    INJECTION = "injection"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    ACCESS_CONTROL = "access_control"


class CVESeverity(Enum):
    """CVE severity levels based on CVSS."""
    NONE = "none"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ExploitabilityLevel(Enum):
    """Exploitability levels for vulnerabilities."""
    THEORETICAL = "theoretical"
    PROOF_OF_CONCEPT = "proof_of_concept"
    FUNCTIONAL = "functional"
    WEAPONIZED = "weaponized"
    WIDESPREAD = "widespread"


class ConfigurationRisk(Enum):
    """Configuration risk levels."""
    SAFE = "safe"
    WEAK = "weak"
    DANGEROUS = "dangerous"
    CRITICAL = "critical"


@dataclass
class CVERecord:
    """Represents a CVE record."""
    cve_id: str
    description: str
    severity: CVESeverity
    cvss_score: float
    published_date: datetime
    affected_products: List[str] = field(default_factory=list)
    attack_vector: str = "unknown"
    attack_complexity: str = "unknown"
    authentication_required: bool = False
    exploit_available: bool = False
    exploitability_level: ExploitabilityLevel = ExploitabilityLevel.THEORETICAL
    references: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)


@dataclass
class ConfigurationWeakness:
    """Represents a configuration weakness."""
    weakness_id: str
    name: str
    description: str
    risk_level: ConfigurationRisk
    affected_components: List[str] = field(default_factory=list)
    exploitation_methods: List[str] = field(default_factory=list)
    remediation_steps: List[str] = field(default_factory=list)
    detection_signatures: List[str] = field(default_factory=list)
    business_impact: str = "Unknown"
    likelihood: float = 0.5


@dataclass
class ZeroDayPotential:
    """Represents zero-day vulnerability potential."""
    potential_id: str
    attack_surface: str
    vulnerability_class: str
    complexity_score: float  # 0.0-1.0, higher = more complex to exploit
    discoverability_score: float  # 0.0-1.0, higher = easier to discover
    impact_score: float  # 0.0-1.0, higher = greater impact
    overall_risk: float  # 0.0-1.0, combined risk score
    exploitation_prerequisites: List[str] = field(default_factory=list)
    potential_attack_vectors: List[str] = field(default_factory=list)
    indicators_of_exploitation: List[str] = field(default_factory=list)
    mitigation_strategies: List[str] = field(default_factory=list)


@dataclass
class VulnerabilityAssessment:
    """Complete vulnerability assessment result."""
    tool_name: str
    assessment_id: str
    cve_matches: List[CVERecord] = field(default_factory=list)
    configuration_weaknesses: List[ConfigurationWeakness] = field(default_factory=list)
    zero_day_potentials: List[ZeroDayPotential] = field(default_factory=list)
    overall_vulnerability_score: float = 0.0
    highest_severity: CVESeverity = CVESeverity.NONE
    exploitable_vulnerabilities: int = 0
    critical_issues: List[str] = field(default_factory=list)
    recommended_actions: List[str] = field(default_factory=list)
    assessment_timestamp: datetime = field(default_factory=datetime.now)
    confidence_score: float = 0.0


class VulnerabilityMapper:
    """
    Enhanced vulnerability mapping engine with CVE integration, configuration analysis,
    and zero-day potential assessment.
    """
    
    def __init__(self):
        """Initialize the vulnerability mapper."""
        self.logger = logging.getLogger(__name__)
        self._cve_database = self._initialize_cve_database()
        self._weakness_patterns = self._initialize_weakness_patterns()
        self._zero_day_indicators = self._initialize_zero_day_indicators()
        self._attack_surface_analyzers = self._initialize_attack_surface_analyzers()
    
    def map_vulnerabilities(
        self,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> VulnerabilityAssessment:
        """
        Perform comprehensive vulnerability mapping for MCP tool.
        
        Args:
            tool_capabilities: Analyzed tool capabilities
            environment_context: Deployment environment context
            
        Returns:
            Complete vulnerability assessment
        """
        self.logger.info(f"Starting vulnerability mapping for {tool_capabilities.tool_name}")
        
        assessment_id = self._generate_assessment_id(tool_capabilities.tool_name)
        
        # CVE matching
        cve_matches = self._match_cves(tool_capabilities)
        
        # Configuration weakness detection
        config_weaknesses = self._detect_configuration_weaknesses(
            tool_capabilities, environment_context
        )
        
        # Zero-day potential assessment
        zero_day_potentials = self._assess_zero_day_potential(
            tool_capabilities, environment_context
        )
        
        # Calculate overall scores and metrics
        vulnerability_score = self._calculate_vulnerability_score(
            cve_matches, config_weaknesses, zero_day_potentials
        )
        
        highest_severity = self._determine_highest_severity(cve_matches, config_weaknesses)
        exploitable_count = self._count_exploitable_vulnerabilities(cve_matches)
        critical_issues = self._identify_critical_issues(
            cve_matches, config_weaknesses, zero_day_potentials
        )
        
        # Generate recommendations
        recommendations = self._generate_recommendations(
            cve_matches, config_weaknesses, zero_day_potentials
        )
        
        # Calculate confidence score
        confidence = self._calculate_confidence_score(
            tool_capabilities, cve_matches, config_weaknesses
        )
        
        assessment = VulnerabilityAssessment(
            tool_name=tool_capabilities.tool_name,
            assessment_id=assessment_id,
            cve_matches=cve_matches,
            configuration_weaknesses=config_weaknesses,
            zero_day_potentials=zero_day_potentials,
            overall_vulnerability_score=vulnerability_score,
            highest_severity=highest_severity,
            exploitable_vulnerabilities=exploitable_count,
            critical_issues=critical_issues,
            recommended_actions=recommendations,
            confidence_score=confidence
        )
        
        self.logger.info(f"Completed vulnerability assessment with {len(cve_matches)} CVE matches")
        return assessment
    
    def _match_cves(self, tool_capabilities: ToolCapabilities) -> List[CVERecord]:
        """Match tool capabilities against CVE database."""
        cve_matches = []
        
        # Extract tool identifiers and signatures
        tool_signatures = self._extract_tool_signatures(tool_capabilities)
        
        # Search CVE database for matches
        for signature in tool_signatures:
            matches = self._search_cve_database(signature)
            cve_matches.extend(matches)
        
        # Capability-based CVE matching
        capability_cves = self._match_cves_by_capability(tool_capabilities)
        cve_matches.extend(capability_cves)
        
        # Remove duplicates and sort by severity
        unique_cves = self._deduplicate_cves(cve_matches)
        unique_cves.sort(key=lambda cve: (cve.cvss_score, cve.published_date), reverse=True)
        
        return unique_cves[:20]  # Limit to top 20 most relevant CVEs
    
    def _detect_configuration_weaknesses(
        self,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Detect configuration weaknesses in tool setup."""
        weaknesses = []
        
        # Analyze each capability category for weaknesses
        for category in tool_capabilities.capability_categories:
            category_weaknesses = self._analyze_capability_weaknesses(
                category, tool_capabilities, environment_context
            )
            weaknesses.extend(category_weaknesses)
        
        # Environment-specific weakness detection
        env_weaknesses = self._detect_environment_weaknesses(
            tool_capabilities, environment_context
        )
        weaknesses.extend(env_weaknesses)
        
        # Access control weaknesses
        access_weaknesses = self._detect_access_control_weaknesses(
            tool_capabilities, environment_context
        )
        weaknesses.extend(access_weaknesses)
        
        # Sort by risk level
        weaknesses.sort(key=lambda w: w.risk_level.value, reverse=True)
        
        return weaknesses
    
    def _assess_zero_day_potential(
        self,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> List[ZeroDayPotential]:
        """Assess zero-day vulnerability potential."""
        potentials = []
        
        # Analyze attack surfaces
        attack_surfaces = self._identify_attack_surfaces(tool_capabilities)
        
        for surface in attack_surfaces:
            potential = self._analyze_attack_surface_for_zero_days(
                surface, tool_capabilities, environment_context
            )
            if potential:
                potentials.append(potential)
        
        # Input validation analysis
        input_potentials = self._assess_input_validation_weaknesses(tool_capabilities)
        potentials.extend(input_potentials)
        
        # Memory safety analysis
        memory_potentials = self._assess_memory_safety_issues(tool_capabilities)
        potentials.extend(memory_potentials)
        
        # Logic flaw analysis
        logic_potentials = self._assess_logic_flaws(tool_capabilities)
        potentials.extend(logic_potentials)
        
        # Sort by overall risk
        potentials.sort(key=lambda p: p.overall_risk, reverse=True)
        
        return potentials[:10]  # Limit to top 10 highest risk potentials
    
    def _initialize_cve_database(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize CVE database with common vulnerability patterns."""
        return {
            "file_system": [
                {
                    "cve_id": "CVE-2023-FSACCESS",
                    "description": "Arbitrary file read/write vulnerability in file system tools",
                    "severity": "high",
                    "cvss_score": 8.1,
                    "attack_vector": "network",
                    "patterns": ["file_read", "file_write", "path_traversal"]
                },
                {
                    "cve_id": "CVE-2023-PATHTRAVERSAL",
                    "description": "Path traversal vulnerability allowing access to restricted files",
                    "severity": "medium",
                    "cvss_score": 6.5,
                    "attack_vector": "network",
                    "patterns": ["../", "..\\", "path_manipulation"]
                }
            ],
            "code_execution": [
                {
                    "cve_id": "CVE-2023-RCE",
                    "description": "Remote code execution through command injection",
                    "severity": "critical",
                    "cvss_score": 9.8,
                    "attack_vector": "network",
                    "patterns": ["command_injection", "shell_execution", "eval"]
                },
                {
                    "cve_id": "CVE-2023-DESERIALIZATION",
                    "description": "Unsafe deserialization leading to code execution",
                    "severity": "high",
                    "cvss_score": 8.5,
                    "attack_vector": "network",
                    "patterns": ["pickle", "deserialize", "unmarshal"]
                }
            ],
            "network_access": [
                {
                    "cve_id": "CVE-2023-SSRF",
                    "description": "Server-side request forgery vulnerability",
                    "severity": "high",
                    "cvss_score": 7.5,
                    "attack_vector": "network",
                    "patterns": ["http_request", "url_fetch", "network_call"]
                }
            ],
            "database_access": [
                {
                    "cve_id": "CVE-2023-SQLI",
                    "description": "SQL injection vulnerability in database queries",
                    "severity": "high",
                    "cvss_score": 8.2,
                    "attack_vector": "network",
                    "patterns": ["sql_query", "database_execute", "query_builder"]
                }
            ]
        }
    
    def _initialize_weakness_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Initialize configuration weakness detection patterns."""
        return {
            "insecure_defaults": {
                "name": "Insecure Default Configuration",
                "risk_level": ConfigurationRisk.DANGEROUS,
                "indicators": ["default_password", "debug_enabled", "no_authentication"],
                "description": "Tool uses insecure default settings that expose security risks"
            },
            "excessive_permissions": {
                "name": "Excessive Permissions",
                "risk_level": ConfigurationRisk.WEAK,
                "indicators": ["admin_access", "root_required", "unrestricted_access"],
                "description": "Tool requires or operates with excessive system permissions"
            },
            "missing_encryption": {
                "name": "Missing Encryption",
                "risk_level": ConfigurationRisk.DANGEROUS,
                "indicators": ["plain_text", "no_tls", "unencrypted_storage"],
                "description": "Sensitive data transmitted or stored without encryption"
            },
            "weak_authentication": {
                "name": "Weak Authentication Mechanisms",
                "risk_level": ConfigurationRisk.CRITICAL,
                "indicators": ["no_auth", "weak_password", "session_fixation"],
                "description": "Authentication mechanisms are weak or missing"
            },
            "insufficient_logging": {
                "name": "Insufficient Security Logging",
                "risk_level": ConfigurationRisk.WEAK,
                "indicators": ["no_logs", "insufficient_audit", "log_tampering"],
                "description": "Security events are not properly logged or monitored"
            }
        }
    
    def _initialize_zero_day_indicators(self) -> Dict[str, Dict[str, Any]]:
        """Initialize zero-day vulnerability indicators."""
        return {
            "input_validation": {
                "vulnerability_class": "Input Validation Flaws",
                "complexity_factors": ["user_input", "data_parsing", "format_handling"],
                "impact_potential": 0.8,
                "discoverability": 0.6
            },
            "memory_corruption": {
                "vulnerability_class": "Memory Corruption",
                "complexity_factors": ["buffer_operations", "pointer_arithmetic", "memory_allocation"],
                "impact_potential": 0.9,
                "discoverability": 0.4
            },
            "race_conditions": {
                "vulnerability_class": "Race Conditions",
                "complexity_factors": ["concurrent_access", "shared_resources", "timing_sensitive"],
                "impact_potential": 0.7,
                "discoverability": 0.3
            },
            "logic_flaws": {
                "vulnerability_class": "Business Logic Flaws",
                "complexity_factors": ["complex_workflows", "state_management", "access_controls"],
                "impact_potential": 0.8,
                "discoverability": 0.5
            },
            "cryptographic_issues": {
                "vulnerability_class": "Cryptographic Vulnerabilities",
                "complexity_factors": ["custom_crypto", "key_management", "random_generation"],
                "impact_potential": 0.9,
                "discoverability": 0.2
            }
        }
    
    def _initialize_attack_surface_analyzers(self) -> Dict[str, Any]:
        """Initialize attack surface analysis patterns."""
        return {
            "network_interfaces": {
                "attack_vectors": ["remote_access", "protocol_exploitation", "network_injection"],
                "risk_multiplier": 1.5
            },
            "file_interfaces": {
                "attack_vectors": ["path_traversal", "file_inclusion", "content_injection"],
                "risk_multiplier": 1.2
            },
            "api_interfaces": {
                "attack_vectors": ["api_abuse", "parameter_manipulation", "injection_attacks"],
                "risk_multiplier": 1.3
            },
            "authentication_interfaces": {
                "attack_vectors": ["credential_attacks", "session_hijacking", "privilege_escalation"],
                "risk_multiplier": 1.8
            }
        }
    
    def _generate_assessment_id(self, tool_name: str) -> str:
        """Generate unique assessment ID."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        tool_hash = hashlib.md5(tool_name.encode()).hexdigest()[:8]
        return f"vuln_assess_{tool_hash}_{timestamp}"
    
    def _extract_tool_signatures(self, tool_capabilities: ToolCapabilities) -> List[str]:
        """Extract tool signatures for CVE matching."""
        signatures = []
        
        # Tool name and variations
        signatures.append(tool_capabilities.tool_name.lower())
        signatures.append(tool_capabilities.tool_id.lower())
        
        # Extract from function names
        for func in tool_capabilities.tool_functions:
            signatures.append(func.name.lower())
            
        # Extract from capability categories
        for category in tool_capabilities.capability_categories:
            signatures.append(category.value.lower())
        
        # Extract from risk indicators
        signatures.extend([indicator.lower() for indicator in tool_capabilities.risk_indicators])
        
        return list(set(signatures))  # Remove duplicates
    
    def _search_cve_database(self, signature: str) -> List[CVERecord]:
        """Search CVE database for signature matches."""
        matches = []
        
        for category, cves in self._cve_database.items():
            for cve_data in cves:
                # Check if signature matches any pattern
                for pattern in cve_data.get("patterns", []):
                    if pattern.lower() in signature or signature in pattern.lower():
                        cve_record = CVERecord(
                            cve_id=cve_data["cve_id"],
                            description=cve_data["description"],
                            severity=CVESeverity(cve_data["severity"]),
                            cvss_score=cve_data["cvss_score"],
                            published_date=datetime.now() - timedelta(days=30),  # Simulate recent
                            attack_vector=cve_data.get("attack_vector", "unknown"),
                            exploit_available=True,
                            exploitability_level=ExploitabilityLevel.FUNCTIONAL
                        )
                        matches.append(cve_record)
                        break
        
        return matches
    
    def _match_cves_by_capability(self, tool_capabilities: ToolCapabilities) -> List[CVERecord]:
        """Match CVEs based on capability categories."""
        capability_cve_mapping = {
            CapabilityCategory.FILE_SYSTEM: "file_system",
            CapabilityCategory.CODE_EXECUTION: "code_execution",
            CapabilityCategory.NETWORK_ACCESS: "network_access",
            CapabilityCategory.DATABASE_ACCESS: "database_access"
        }
        
        matches = []
        for capability in tool_capabilities.capability_categories:
            if capability in capability_cve_mapping:
                category = capability_cve_mapping[capability]
                category_matches = self._get_cves_for_category(category)
                matches.extend(category_matches)
        
        return matches
    
    def _get_cves_for_category(self, category: str) -> List[CVERecord]:
        """Get CVEs for a specific category."""
        if category not in self._cve_database:
            return []
        
        cves = []
        for cve_data in self._cve_database[category]:
            cve_record = CVERecord(
                cve_id=cve_data["cve_id"],
                description=cve_data["description"],
                severity=CVESeverity(cve_data["severity"]),
                cvss_score=cve_data["cvss_score"],
                published_date=datetime.now() - timedelta(days=30),
                attack_vector=cve_data.get("attack_vector", "unknown"),
                exploit_available=True,
                exploitability_level=ExploitabilityLevel.FUNCTIONAL
            )
            cves.append(cve_record)
        
        return cves
    
    def _deduplicate_cves(self, cve_list: List[CVERecord]) -> List[CVERecord]:
        """Remove duplicate CVE records."""
        seen_cves = set()
        unique_cves = []
        
        for cve in cve_list:
            if cve.cve_id not in seen_cves:
                seen_cves.add(cve.cve_id)
                unique_cves.append(cve)
        
        return unique_cves
    
    def _analyze_capability_weaknesses(
        self,
        capability: CapabilityCategory,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Analyze weaknesses for a specific capability."""
        weaknesses = []
        
        # Map capabilities to potential weaknesses
        capability_weakness_mapping = {
            CapabilityCategory.FILE_SYSTEM: [
                self._create_file_system_weaknesses,
            ],
            CapabilityCategory.NETWORK_ACCESS: [
                self._create_network_weaknesses,
            ],
            CapabilityCategory.CODE_EXECUTION: [
                self._create_execution_weaknesses,
            ],
            CapabilityCategory.AUTHENTICATION: [
                self._create_auth_weaknesses,
            ],
            CapabilityCategory.DATABASE_ACCESS: [
                self._create_database_weaknesses,
            ]
        }
        
        if capability in capability_weakness_mapping:
            for weakness_creator in capability_weakness_mapping[capability]:
                weakness = weakness_creator(tool_capabilities, environment_context)
                if weakness:
                    weaknesses.extend(weakness)
        
        return weaknesses
    
    def _create_file_system_weaknesses(
        self, tool_capabilities: ToolCapabilities, environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Create file system related weaknesses."""
        weaknesses = []
        
        # Path traversal vulnerability
        if any("read" in func.name.lower() or "write" in func.name.lower() 
               for func in tool_capabilities.tool_functions):
            weakness = ConfigurationWeakness(
                weakness_id="fs_path_traversal",
                name="Path Traversal Vulnerability",
                description="File operations may be vulnerable to path traversal attacks",
                risk_level=ConfigurationRisk.DANGEROUS,
                affected_components=["file_operations"],
                exploitation_methods=["../../../etc/passwd", "..\\..\\windows\\system32"],
                remediation_steps=[
                    "Implement path sanitization",
                    "Use allow-lists for file access",
                    "Run with minimal file system permissions"
                ],
                detection_signatures=["../", "..\\", "%2e%2e%2f"],
                business_impact="Unauthorized file access leading to data breach",
                likelihood=0.7
            )
            weaknesses.append(weakness)
        
        # Unrestricted file access
        if tool_capabilities.requires_privileges:
            weakness = ConfigurationWeakness(
                weakness_id="fs_unrestricted_access",
                name="Unrestricted File System Access",
                description="Tool has broad file system access permissions",
                risk_level=ConfigurationRisk.WEAK,
                affected_components=["file_permissions"],
                exploitation_methods=["privilege_abuse", "file_modification"],
                remediation_steps=[
                    "Apply principle of least privilege",
                    "Restrict file access to necessary directories only",
                    "Implement file access monitoring"
                ],
                business_impact="Potential for unauthorized file access and modification",
                likelihood=0.5
            )
            weaknesses.append(weakness)
        
        return weaknesses
    
    def _create_network_weaknesses(
        self, tool_capabilities: ToolCapabilities, environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Create network related weaknesses."""
        weaknesses = []
        
        # SSRF vulnerability
        if tool_capabilities.external_access:
            weakness = ConfigurationWeakness(
                weakness_id="net_ssrf",
                name="Server-Side Request Forgery Risk",
                description="Network access capabilities may enable SSRF attacks",
                risk_level=ConfigurationRisk.DANGEROUS,
                affected_components=["network_requests"],
                exploitation_methods=["internal_network_scanning", "service_enumeration"],
                remediation_steps=[
                    "Implement URL allow-lists",
                    "Validate and sanitize all URLs",
                    "Use network segmentation"
                ],
                detection_signatures=["localhost", "127.0.0.1", "internal_ip_ranges"],
                business_impact="Access to internal systems and data",
                likelihood=0.6
            )
            weaknesses.append(weakness)
        
        return weaknesses
    
    def _create_execution_weaknesses(
        self, tool_capabilities: ToolCapabilities, environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Create code execution related weaknesses."""
        weaknesses = []
        
        # Command injection risk
        weakness = ConfigurationWeakness(
            weakness_id="exec_command_injection",
            name="Command Injection Vulnerability",
            description="Code execution capabilities may be vulnerable to injection attacks",
            risk_level=ConfigurationRisk.CRITICAL,
            affected_components=["command_execution"],
            exploitation_methods=["shell_injection", "command_chaining"],
            remediation_steps=[
                "Use parameterized commands",
                "Implement input validation",
                "Run with restricted privileges"
            ],
            detection_signatures=[";", "|", "&", "`", "$("],
            business_impact="Full system compromise possible",
            likelihood=0.8
        )
        weaknesses.append(weakness)
        
        return weaknesses
    
    def _create_auth_weaknesses(
        self, tool_capabilities: ToolCapabilities, environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Create authentication related weaknesses."""
        weaknesses = []
        
        # Weak authentication
        weakness = ConfigurationWeakness(
            weakness_id="auth_weak_mechanism",
            name="Weak Authentication Mechanism",
            description="Authentication controls may be insufficient or bypassable",
            risk_level=ConfigurationRisk.CRITICAL,
            affected_components=["authentication"],
            exploitation_methods=["credential_brute_force", "session_hijacking"],
            remediation_steps=[
                "Implement multi-factor authentication",
                "Use strong session management",
                "Enable account lockout policies"
            ],
            business_impact="Unauthorized access to system and data",
            likelihood=0.7
        )
        weaknesses.append(weakness)
        
        return weaknesses
    
    def _create_database_weaknesses(
        self, tool_capabilities: ToolCapabilities, environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Create database related weaknesses."""
        weaknesses = []
        
        # SQL injection risk
        weakness = ConfigurationWeakness(
            weakness_id="db_sql_injection",
            name="SQL Injection Vulnerability",
            description="Database operations may be vulnerable to SQL injection",
            risk_level=ConfigurationRisk.DANGEROUS,
            affected_components=["database_queries"],
            exploitation_methods=["union_injection", "blind_injection"],
            remediation_steps=[
                "Use parameterized queries",
                "Implement input validation",
                "Apply least privilege to database access"
            ],
            detection_signatures=["'", "UNION", "SELECT", "--"],
            business_impact="Database compromise and data theft",
            likelihood=0.7
        )
        weaknesses.append(weakness)
        
        return weaknesses
    
    def _detect_environment_weaknesses(
        self,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Detect environment-specific weaknesses."""
        weaknesses = []
        
        # Public exposure risk
        if environment_context.network_exposure.value in ["internet_facing", "public"]:
            weakness = ConfigurationWeakness(
                weakness_id="env_public_exposure",
                name="Public Network Exposure",
                description="Tool is exposed to public networks increasing attack surface",
                risk_level=ConfigurationRisk.DANGEROUS,
                affected_components=["network_interface"],
                exploitation_methods=["remote_exploitation", "network_scanning"],
                remediation_steps=[
                    "Implement network access controls",
                    "Use VPN or private networks",
                    "Enable rate limiting and monitoring"
                ],
                business_impact="Increased exposure to external threats",
                likelihood=0.8
            )
            weaknesses.append(weakness)
        
        return weaknesses
    
    def _detect_access_control_weaknesses(
        self,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> List[ConfigurationWeakness]:
        """Detect access control weaknesses."""
        weaknesses = []
        
        # Excessive privileges
        if tool_capabilities.requires_privileges:
            weakness = ConfigurationWeakness(
                weakness_id="ac_excessive_privileges",
                name="Excessive System Privileges",
                description="Tool operates with elevated privileges that may be abused",
                risk_level=ConfigurationRisk.WEAK,
                affected_components=["privilege_level"],
                exploitation_methods=["privilege_abuse", "lateral_movement"],
                remediation_steps=[
                    "Apply principle of least privilege",
                    "Use service accounts with minimal permissions",
                    "Implement privilege monitoring"
                ],
                business_impact="Potential for privilege escalation attacks",
                likelihood=0.6
            )
            weaknesses.append(weakness)
        
        return weaknesses
    
    def _identify_attack_surfaces(self, tool_capabilities: ToolCapabilities) -> List[str]:
        """Identify attack surfaces for zero-day analysis."""
        surfaces = []
        
        capability_surface_mapping = {
            CapabilityCategory.NETWORK_ACCESS: ["network_interfaces", "api_interfaces"],
            CapabilityCategory.FILE_SYSTEM: ["file_interfaces"],
            CapabilityCategory.AUTHENTICATION: ["authentication_interfaces"],
            CapabilityCategory.CODE_EXECUTION: ["execution_interfaces"],
            CapabilityCategory.DATABASE_ACCESS: ["database_interfaces"]
        }
        
        for capability in tool_capabilities.capability_categories:
            if capability in capability_surface_mapping:
                surfaces.extend(capability_surface_mapping[capability])
        
        return list(set(surfaces))  # Remove duplicates
    
    def _analyze_attack_surface_for_zero_days(
        self,
        surface: str,
        tool_capabilities: ToolCapabilities,
        environment_context: EnvironmentContext
    ) -> Optional[ZeroDayPotential]:
        """Analyze an attack surface for zero-day potential."""
        if surface not in self._attack_surface_analyzers:
            return None
        
        analyzer = self._attack_surface_analyzers[surface]
        potential_id = f"zd_{surface}_{tool_capabilities.tool_name}"
        
        # Calculate complexity score
        complexity = self._calculate_zero_day_complexity(surface, tool_capabilities)
        
        # Calculate discoverability score
        discoverability = self._calculate_zero_day_discoverability(surface, tool_capabilities)
        
        # Calculate impact score
        impact = self._calculate_zero_day_impact(surface, environment_context)
        
        # Calculate overall risk
        overall_risk = (impact * discoverability) / (complexity + 0.1)  # Avoid division by zero
        
        # Generate potential attack vectors
        attack_vectors = analyzer["attack_vectors"].copy()
        
        # Generate mitigation strategies
        mitigations = self._generate_zero_day_mitigations(surface)
        
        return ZeroDayPotential(
            potential_id=potential_id,
            attack_surface=surface,
            vulnerability_class=f"{surface.title()} Vulnerability",
            complexity_score=complexity,
            discoverability_score=discoverability,
            impact_score=impact,
            overall_risk=min(overall_risk, 1.0),  # Cap at 1.0
            exploitation_prerequisites=["system_access", "technical_knowledge"],
            potential_attack_vectors=attack_vectors,
            indicators_of_exploitation=["unusual_network_traffic", "unexpected_system_calls"],
            mitigation_strategies=mitigations
        )
    
    def _assess_input_validation_weaknesses(
        self, tool_capabilities: ToolCapabilities
    ) -> List[ZeroDayPotential]:
        """Assess input validation weaknesses for zero-day potential."""
        potentials = []
        
        # Check if tool processes user input
        has_input_processing = any(
            func for func in tool_capabilities.tool_functions
            if any(keyword in func.description.lower() 
                   for keyword in ["input", "parse", "process", "validate"])
        )
        
        if has_input_processing:
            potential = ZeroDayPotential(
                potential_id=f"zd_input_validation_{tool_capabilities.tool_name}",
                attack_surface="input_processing",
                vulnerability_class="Input Validation Flaw",
                complexity_score=0.4,
                discoverability_score=0.7,
                impact_score=0.8,
                overall_risk=0.7,
                exploitation_prerequisites=["input_access", "payload_crafting"],
                potential_attack_vectors=["buffer_overflow", "format_string", "injection_attack"],
                indicators_of_exploitation=["malformed_input", "crash_patterns", "memory_corruption"],
                mitigation_strategies=[
                    "Implement strict input validation",
                    "Use safe parsing libraries",
                    "Enable address space layout randomization"
                ]
            )
            potentials.append(potential)
        
        return potentials
    
    def _assess_memory_safety_issues(
        self, tool_capabilities: ToolCapabilities
    ) -> List[ZeroDayPotential]:
        """Assess memory safety issues for zero-day potential."""
        potentials = []
        
        # Check for memory-unsafe operations
        has_memory_operations = any(
            func for func in tool_capabilities.tool_functions
            if any(keyword in func.description.lower()
                   for keyword in ["memory", "buffer", "allocation", "pointer"])
        )
        
        if has_memory_operations:
            potential = ZeroDayPotential(
                potential_id=f"zd_memory_safety_{tool_capabilities.tool_name}",
                attack_surface="memory_management",
                vulnerability_class="Memory Corruption",
                complexity_score=0.7,
                discoverability_score=0.3,
                impact_score=0.9,
                overall_risk=0.6,
                exploitation_prerequisites=["memory_layout_knowledge", "exploit_development"],
                potential_attack_vectors=["buffer_overflow", "use_after_free", "double_free"],
                indicators_of_exploitation=["segmentation_faults", "heap_corruption", "stack_smashing"],
                mitigation_strategies=[
                    "Use memory-safe languages",
                    "Enable stack canaries and ASLR",
                    "Implement bounds checking"
                ]
            )
            potentials.append(potential)
        
        return potentials
    
    def _assess_logic_flaws(self, tool_capabilities: ToolCapabilities) -> List[ZeroDayPotential]:
        """Assess logic flaws for zero-day potential."""
        potentials = []
        
        # Check for complex business logic
        has_complex_logic = len(tool_capabilities.tool_functions) > 5
        
        if has_complex_logic:
            potential = ZeroDayPotential(
                potential_id=f"zd_logic_flaw_{tool_capabilities.tool_name}",
                attack_surface="business_logic",
                vulnerability_class="Logic Flaw",
                complexity_score=0.5,
                discoverability_score=0.4,
                impact_score=0.7,
                overall_risk=0.5,
                exploitation_prerequisites=["logic_understanding", "workflow_knowledge"],
                potential_attack_vectors=["workflow_bypass", "state_manipulation", "race_condition"],
                indicators_of_exploitation=["unexpected_state_changes", "workflow_anomalies"],
                mitigation_strategies=[
                    "Implement state validation",
                    "Use formal verification methods",
                    "Conduct thorough logic testing"
                ]
            )
            potentials.append(potential)
        
        return potentials
    
    def _calculate_vulnerability_score(
        self,
        cve_matches: List[CVERecord],
        config_weaknesses: List[ConfigurationWeakness],
        zero_day_potentials: List[ZeroDayPotential]
    ) -> float:
        """Calculate overall vulnerability score."""
        score = 0.0
        
        # CVE contribution (40% weight)
        if cve_matches:
            avg_cvss = sum(cve.cvss_score for cve in cve_matches) / len(cve_matches)
            score += (avg_cvss / 10.0) * 0.4
        
        # Configuration weakness contribution (35% weight)
        if config_weaknesses:
            risk_scores = {
                ConfigurationRisk.SAFE: 0.0,
                ConfigurationRisk.WEAK: 0.3,
                ConfigurationRisk.DANGEROUS: 0.7,
                ConfigurationRisk.CRITICAL: 1.0
            }
            avg_config_score = sum(risk_scores[w.risk_level] for w in config_weaknesses) / len(config_weaknesses)
            score += avg_config_score * 0.35
        
        # Zero-day potential contribution (25% weight)
        if zero_day_potentials:
            avg_zd_score = sum(zd.overall_risk for zd in zero_day_potentials) / len(zero_day_potentials)
            score += avg_zd_score * 0.25
        
        return min(score, 1.0)  # Cap at 1.0
    
    def _determine_highest_severity(
        self, cve_matches: List[CVERecord], config_weaknesses: List[ConfigurationWeakness]
    ) -> CVESeverity:
        """Determine the highest severity level."""
        highest = CVESeverity.NONE
        
        # Check CVE severities
        for cve in cve_matches:
            if cve.severity.value > highest.value:
                highest = cve.severity
        
        # Check configuration risk levels
        config_severity_mapping = {
            ConfigurationRisk.SAFE: CVESeverity.NONE,
            ConfigurationRisk.WEAK: CVESeverity.LOW,
            ConfigurationRisk.DANGEROUS: CVESeverity.HIGH,
            ConfigurationRisk.CRITICAL: CVESeverity.CRITICAL
        }
        
        for weakness in config_weaknesses:
            mapped_severity = config_severity_mapping[weakness.risk_level]
            if mapped_severity.value > highest.value:
                highest = mapped_severity
        
        return highest
    
    def _count_exploitable_vulnerabilities(self, cve_matches: List[CVERecord]) -> int:
        """Count exploitable vulnerabilities."""
        return sum(1 for cve in cve_matches if cve.exploit_available)
    
    def _identify_critical_issues(
        self,
        cve_matches: List[CVERecord],
        config_weaknesses: List[ConfigurationWeakness],
        zero_day_potentials: List[ZeroDayPotential]
    ) -> List[str]:
        """Identify critical security issues."""
        critical_issues = []
        
        # Critical CVEs
        critical_cves = [cve for cve in cve_matches if cve.severity == CVESeverity.CRITICAL]
        for cve in critical_cves:
            critical_issues.append(f"Critical CVE: {cve.cve_id} - {cve.description}")
        
        # Critical configuration weaknesses
        critical_configs = [w for w in config_weaknesses if w.risk_level == ConfigurationRisk.CRITICAL]
        for weakness in critical_configs:
            critical_issues.append(f"Critical Configuration: {weakness.name}")
        
        # High-risk zero-day potentials
        high_risk_zd = [zd for zd in zero_day_potentials if zd.overall_risk > 0.8]
        for zd in high_risk_zd:
            critical_issues.append(f"High Zero-Day Risk: {zd.vulnerability_class}")
        
        return critical_issues
    
    def _generate_recommendations(
        self,
        cve_matches: List[CVERecord],
        config_weaknesses: List[ConfigurationWeakness],
        zero_day_potentials: List[ZeroDayPotential]
    ) -> List[str]:
        """Generate security recommendations."""
        recommendations = []
        
        # CVE-based recommendations
        if cve_matches:
            recommendations.append("Apply security patches for identified CVEs")
            recommendations.append("Monitor threat intelligence for exploit availability")
        
        # Configuration recommendations
        for weakness in config_weaknesses:
            recommendations.extend(weakness.remediation_steps)
        
        # Zero-day recommendations
        for zd in zero_day_potentials:
            recommendations.extend(zd.mitigation_strategies)
        
        # General recommendations
        general_recs = [
            "Implement defense-in-depth security controls",
            "Enable security monitoring and alerting",
            "Conduct regular security assessments",
            "Maintain incident response capabilities"
        ]
        recommendations.extend(general_recs)
        
        # Remove duplicates while preserving order
        unique_recommendations = []
        for rec in recommendations:
            if rec not in unique_recommendations:
                unique_recommendations.append(rec)
        
        return unique_recommendations[:15]  # Limit to top 15 recommendations
    
    def _calculate_confidence_score(
        self,
        tool_capabilities: ToolCapabilities,
        cve_matches: List[CVERecord],
        config_weaknesses: List[ConfigurationWeakness]
    ) -> float:
        """Calculate confidence score for vulnerability assessment."""
        base_confidence = 0.6
        
        # Increase confidence with more tool information
        if tool_capabilities.tool_functions:
            base_confidence += 0.1
        
        if tool_capabilities.risk_indicators:
            base_confidence += 0.1
        
        # Increase confidence with more vulnerability findings
        if cve_matches:
            base_confidence += 0.1
        
        if config_weaknesses:
            base_confidence += 0.1
        
        return min(base_confidence, 0.9)  # Cap at 90%
    
    def _calculate_zero_day_complexity(self, surface: str, tool_capabilities: ToolCapabilities) -> float:
        """Calculate complexity score for zero-day exploitation."""
        base_complexity = 0.5
        
        # Adjust based on surface type
        surface_complexity = {
            "network_interfaces": 0.4,
            "file_interfaces": 0.3,
            "api_interfaces": 0.5,
            "authentication_interfaces": 0.7,
            "execution_interfaces": 0.8
        }
        
        if surface in surface_complexity:
            base_complexity = surface_complexity[surface]
        
        # Adjust for tool complexity
        if len(tool_capabilities.tool_functions) > 10:
            base_complexity += 0.2
        
        return min(base_complexity, 1.0)
    
    def _calculate_zero_day_discoverability(self, surface: str, tool_capabilities: ToolCapabilities) -> float:
        """Calculate discoverability score for zero-day vulnerabilities."""
        base_discoverability = 0.4
        
        # Adjust based on surface type
        if surface in ["network_interfaces", "api_interfaces"]:
            base_discoverability = 0.7
        elif surface == "authentication_interfaces":
            base_discoverability = 0.6
        
        # Adjust for external access
        if tool_capabilities.external_access:
            base_discoverability += 0.2
        
        return min(base_discoverability, 1.0)
    
    def _calculate_zero_day_impact(self, surface: str, environment_context: EnvironmentContext) -> float:
        """Calculate impact score for zero-day vulnerabilities."""
        base_impact = 0.5
        
        # Adjust based on data sensitivity
        sensitivity_impact = {
            "public": 0.3,
            "internal": 0.5,
            "confidential": 0.8,
            "restricted": 0.9,
            "top_secret": 1.0
        }
        
        if environment_context.data_sensitivity.value in sensitivity_impact:
            base_impact = sensitivity_impact[environment_context.data_sensitivity.value]
        
        # Adjust for network exposure
        if environment_context.network_exposure.value in ["internet_facing", "public"]:
            base_impact += 0.1
        
        return min(base_impact, 1.0)
    
    def _generate_zero_day_mitigations(self, surface: str) -> List[str]:
        """Generate mitigations for zero-day vulnerabilities."""
        mitigation_mapping = {
            "network_interfaces": [
                "Implement network segmentation",
                "Use intrusion detection systems",
                "Enable network monitoring"
            ],
            "file_interfaces": [
                "Implement file integrity monitoring",
                "Use sandboxing for file operations",
                "Enable file access logging"
            ],
            "api_interfaces": [
                "Implement API rate limiting",
                "Use API gateways with security controls",
                "Enable API request monitoring"
            ],
            "authentication_interfaces": [
                "Implement multi-factor authentication",
                "Use adaptive authentication",
                "Enable authentication logging"
            ]
        }
        
        return mitigation_mapping.get(surface, ["Implement general security controls"]) 