"""
CSV report generator for HawkEye security reconnaissance tool.

This module provides CSV format report generation with tabular data output,
proper formatting, and comprehensive data export for all scan results,
detection findings, and risk assessments.
"""

import csv
import time
from pathlib import Path
from typing import Dict, Any, Optional, List
from io import StringIO

from .base import BaseReporter, ReportData, ReportFormat, ReportingError
from ..assessment.base import RiskLevel, VulnerabilityCategory
from ..detection.base import TransportType, MCPServerType
from ..scanner.base import PortState, ScanType
from ..utils.logging import get_logger


class CSVReporter(BaseReporter):
    """CSV format report generator."""
    
    def __init__(self, settings=None, delimiter: str = ',', quoting: int = csv.QUOTE_MINIMAL):
        """
        Initialize CSV reporter.
        
        Args:
            settings: Configuration settings
            delimiter: CSV field delimiter
            quoting: CSV quoting style
        """
        super().__init__(settings)
        self.delimiter = delimiter
        self.quoting = quoting
        self.logger = get_logger(self.__class__.__name__)
    
    def get_format(self) -> ReportFormat:
        """Get the report format."""
        return ReportFormat.CSV
    
    def generate_report(self, data: ReportData, output_path: Optional[Path] = None) -> str:
        """
        Generate CSV report from data.
        
        Args:
            data: Report data to generate from
            output_path: Optional path to save the report
            
        Returns:
            str: Path to generated report file or CSV content
            
        Raises:
            ReportingError: If report generation fails
        """
        start_time = time.time()
        success = False
        
        try:
            # Validate input data
            self.validate_data(data)
            
            # Generate CSV content
            csv_content = self._generate_csv_content(data)
            
            # Save to file if path provided
            if output_path:
                output_file = self._create_output_path(output_path, data)
                self._save_csv_file(csv_content, output_file)
                result = str(output_file)
                self.logger.info(f"CSV report saved to: {output_file}")
            else:
                result = csv_content
                self.logger.info("CSV report generated in memory")
            
            success = True
            return result
            
        except Exception as e:
            self.logger.error(f"Failed to generate CSV report: {e}")
            raise ReportingError(f"CSV report generation failed: {e}")
        
        finally:
            generation_time = time.time() - start_time
            self._update_statistics(success, generation_time)
    
    def _generate_csv_content(self, data: ReportData) -> str:
        """
        Generate CSV content from report data.
        
        Args:
            data: Report data to convert
            
        Returns:
            str: CSV formatted content
        """
        output = StringIO()
        
        # Write metadata section
        self._write_metadata_section(output, data.metadata)
        
        # Write summary section
        self._write_summary_section(output, data)
        
        # Write scan results if available
        if data.has_scan_data:
            self._write_scan_results_section(output, data.scan_results)
        
        # Write detection results if available
        if data.has_detection_data:
            self._write_detection_results_section(output, data.detection_results)
        
        # Write assessment results if available
        if data.has_assessment_data:
            self._write_assessment_results_section(output, data.assessment_results)
        
        # Write recommendations if available
        if data.recommendations:
            self._write_recommendations_section(output, data.recommendations)
        
        return output.getvalue()
    
    def _write_metadata_section(self, output: StringIO, metadata) -> None:
        """Write metadata section to CSV."""
        output.write("# REPORT METADATA\n")
        
        writer = csv.writer(output, delimiter=self.delimiter, quoting=self.quoting)
        writer.writerow(["Field", "Value"])
        writer.writerow(["Title", metadata.title])
        writer.writerow(["Report Type", metadata.report_type.value])
        writer.writerow(["Format", metadata.format.value])
        writer.writerow(["Generated At", metadata.generated_timestamp])
        writer.writerow(["Generated By", metadata.generated_by])
        writer.writerow(["Version", metadata.version])
        
        if metadata.description:
            writer.writerow(["Description", metadata.description])
        if metadata.author:
            writer.writerow(["Author", metadata.author])
        if metadata.organization:
            writer.writerow(["Organization", metadata.organization])
        
        writer.writerow(["Classification", metadata.classification])
        
        output.write("\n")
    
    def _write_summary_section(self, output: StringIO, data: ReportData) -> None:
        """Write summary section to CSV."""
        output.write("# EXECUTIVE SUMMARY\n")
        
        writer = csv.writer(output, delimiter=self.delimiter, quoting=self.quoting)
        writer.writerow(["Metric", "Value"])
        writer.writerow(["Total Targets", data.total_targets])
        writer.writerow(["Has Scan Data", data.has_scan_data])
        writer.writerow(["Has Detection Data", data.has_detection_data])
        writer.writerow(["Has Assessment Data", data.has_assessment_data])
        writer.writerow(["Critical Findings", len(data.critical_findings)])
        writer.writerow(["High Risk Targets", len(data.high_risk_targets)])
        
        # Add summary statistics if available
        if data.scan_summary:
            writer.writerow(["Total Ports Scanned", data.scan_summary.total_ports_scanned])
            writer.writerow(["Open Ports", data.scan_summary.open_ports])
            writer.writerow(["Services Detected", data.scan_summary.services_detected])
        
        if data.detection_summary:
            writer.writerow(["MCP Servers Detected", data.detection_summary.mcp_servers_detected])
            writer.writerow(["Detection Rate", f"{data.detection_summary.detection_rate:.2%}"])
            writer.writerow(["Security Rate", f"{data.detection_summary.security_rate:.2%}"])
        
        if data.risk_summary:
            writer.writerow(["Total Assessments", data.risk_summary.total_assessments])
            writer.writerow(["Critical Risk Targets", data.risk_summary.critical_risk_targets])
            writer.writerow(["High Risk Targets", data.risk_summary.high_risk_targets])
            writer.writerow(["Average Risk Score", f"{data.risk_summary.average_risk_score:.2f}"])
        
        output.write("\n")
    
    def _write_scan_results_section(self, output: StringIO, scan_results) -> None:
        """Write scan results section to CSV."""
        output.write("# SCAN RESULTS\n")
        
        writer = csv.writer(output, delimiter=self.delimiter, quoting=self.quoting)
        
        # Write headers
        headers = [
            "Host", "Port", "State", "Scan Type", "Timestamp", "Response Time (ms)",
            "Service Name", "Service Version", "Service Product", "Service Banner",
            "Service Confidence", "Error"
        ]
        writer.writerow(headers)
        
        # Write data rows
        for result in scan_results:
            row = [
                result.target.host,
                result.port,
                result.state.value,
                result.scan_type.value,
                time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime(result.timestamp)),
                f"{result.response_time * 1000:.2f}" if result.response_time else "",
                result.service_info.name if result.service_info else "",
                result.service_info.version if result.service_info else "",
                result.service_info.product if result.service_info else "",
                result.service_info.banner if result.service_info else "",
                f"{result.service_info.confidence:.2f}" if result.service_info else "",
                result.error or ""
            ]
            writer.writerow(row)
        
        output.write("\n")
    
    def _write_detection_results_section(self, output: StringIO, detection_results) -> None:
        """Write detection results section to CSV."""
        output.write("# MCP DETECTION RESULTS\n")
        
        writer = csv.writer(output, delimiter=self.delimiter, quoting=self.quoting)
        
        # Write headers
        headers = [
            "Target Host", "Detection Method", "Timestamp", "Success", "MCP Detected",
            "Confidence", "Transport Type", "Server Type", "Port", "Is Secure",
            "Has Authentication", "Endpoint URL", "Capabilities", "Tools", "Resources",
            "Version", "Risk Level", "Error"
        ]
        writer.writerow(headers)
        
        # Write data rows
        for result in detection_results:
            server = result.mcp_server
            row = [
                result.target_host,
                result.detection_method.value,
                time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime(result.timestamp)),
                result.success,
                result.is_mcp_detected,
                f"{result.confidence:.2f}",
                server.transport_type.value if server else "",
                server.server_type.value if server else "",
                server.port if server else "",
                server.is_secure if server else "",
                server.has_authentication if server else "",
                server.endpoint_url if server else "",
                "; ".join(server.capabilities) if server and server.capabilities else "",
                "; ".join(server.tools) if server and server.tools else "",
                "; ".join(server.resources) if server and server.resources else "",
                server.version if server else "",
                result.risk_level,
                result.error or ""
            ]
            writer.writerow(row)
        
        output.write("\n")
    
    def _write_assessment_results_section(self, output: StringIO, assessment_results) -> None:
        """Write assessment results section to CSV."""
        output.write("# RISK ASSESSMENT RESULTS\n")
        
        writer = csv.writer(output, delimiter=self.delimiter, quoting=self.quoting)
        
        # Write summary headers
        summary_headers = [
            "Target Host", "Assessment Timestamp", "Overall Risk Level", "Overall Risk Score",
            "Total Findings", "Critical Findings", "High Findings", "Total Vulnerabilities",
            "Exploitable Vulnerabilities", "Unpatched Vulnerabilities", "Assessment Duration (s)"
        ]
        writer.writerow(summary_headers)
        
        # Write summary data
        for result in assessment_results:
            row = [
                result.target_host,
                time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime(result.assessment_timestamp)),
                result.overall_risk_level.value,
                f"{result.overall_risk_score:.2f}",
                len(result.findings),
                len(result.critical_findings),
                len(result.high_findings),
                len(result.vulnerabilities),
                len(result.exploitable_vulnerabilities),
                len(result.unpatched_vulnerabilities),
                f"{result.assessment_duration:.2f}" if result.assessment_duration else ""
            ]
            writer.writerow(row)
        
        output.write("\n")
        
        # Write detailed findings
        output.write("# DETAILED FINDINGS\n")
        
        findings_headers = [
            "Target Host", "Finding ID", "Title", "Description", "Category", "Severity",
            "Confidence", "Risk Score", "Affected Asset", "Remediation", "Compliance Violations"
        ]
        writer.writerow(findings_headers)
        
        for result in assessment_results:
            for finding in result.findings:
                row = [
                    result.target_host,
                    finding.id,
                    finding.title,
                    finding.description,
                    finding.category.value,
                    finding.severity.value,
                    f"{finding.confidence:.2f}",
                    f"{finding.risk_score:.2f}",
                    finding.affected_asset,
                    finding.remediation or "",
                    "; ".join([cv.value for cv in finding.compliance_violations])
                ]
                writer.writerow(row)
        
        output.write("\n")
    
    def _write_recommendations_section(self, output: StringIO, recommendations: List[str]) -> None:
        """Write recommendations section to CSV."""
        output.write("# RECOMMENDATIONS\n")
        
        writer = csv.writer(output, delimiter=self.delimiter, quoting=self.quoting)
        writer.writerow(["Priority", "Recommendation"])
        
        for i, recommendation in enumerate(recommendations, 1):
            writer.writerow([i, recommendation])
        
        output.write("\n")
    
    def _save_csv_file(self, content: str, output_path: Path) -> None:
        """
        Save CSV content to file.
        
        Args:
            content: CSV content to save
            output_path: Path to save file
            
        Raises:
            ReportingError: If file save fails
        """
        try:
            with open(output_path, 'w', encoding='utf-8', newline='') as f:
                f.write(content)
        except IOError as e:
            raise ReportingError(f"Failed to save CSV report to {output_path}: {e}")
    
    def generate_separate_files(self, data: ReportData, base_path: Path) -> List[str]:
        """
        Generate separate CSV files for each data type.
        
        Args:
            data: Report data to generate from
            base_path: Base path for output files
            
        Returns:
            List[str]: List of generated file paths
        """
        generated_files = []
        
        try:
            # Validate input data
            self.validate_data(data)
            
            base_path = Path(base_path)
            base_path.mkdir(parents=True, exist_ok=True)
            
            # Generate metadata file
            metadata_file = base_path / "metadata.csv"
            self._generate_metadata_file(data.metadata, metadata_file)
            generated_files.append(str(metadata_file))
            
            # Generate scan results file
            if data.has_scan_data:
                scan_file = base_path / "scan_results.csv"
                self._generate_scan_results_file(data.scan_results, scan_file)
                generated_files.append(str(scan_file))
            
            # Generate detection results file
            if data.has_detection_data:
                detection_file = base_path / "detection_results.csv"
                self._generate_detection_results_file(data.detection_results, detection_file)
                generated_files.append(str(detection_file))
            
            # Generate assessment results file
            if data.has_assessment_data:
                assessment_file = base_path / "assessment_results.csv"
                self._generate_assessment_results_file(data.assessment_results, assessment_file)
                generated_files.append(str(assessment_file))
            
            self.logger.info(f"Generated {len(generated_files)} CSV files in {base_path}")
            return generated_files
            
        except Exception as e:
            self.logger.error(f"Failed to generate separate CSV files: {e}")
            raise ReportingError(f"Separate CSV file generation failed: {e}")
    
    def _generate_metadata_file(self, metadata, output_path: Path) -> None:
        """Generate metadata CSV file."""
        with open(output_path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f, delimiter=self.delimiter, quoting=self.quoting)
            writer.writerow(["Field", "Value"])
            writer.writerow(["Title", metadata.title])
            writer.writerow(["Report Type", metadata.report_type.value])
            writer.writerow(["Generated At", metadata.generated_timestamp])
            writer.writerow(["Generated By", metadata.generated_by])
            writer.writerow(["Version", metadata.version])
    
    def _generate_scan_results_file(self, scan_results, output_path: Path) -> None:
        """Generate scan results CSV file."""
        with open(output_path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f, delimiter=self.delimiter, quoting=self.quoting)
            
            headers = ["Host", "Port", "State", "Scan Type", "Timestamp", "Response Time (ms)",
                      "Service Name", "Service Version", "Error"]
            writer.writerow(headers)
            
            for result in scan_results:
                row = [
                    result.target.host,
                    result.port,
                    result.state.value,
                    result.scan_type.value,
                    time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime(result.timestamp)),
                    f"{result.response_time * 1000:.2f}" if result.response_time else "",
                    result.service_info.name if result.service_info else "",
                    result.service_info.version if result.service_info else "",
                    result.error or ""
                ]
                writer.writerow(row)
    
    def _generate_detection_results_file(self, detection_results, output_path: Path) -> None:
        """Generate detection results CSV file."""
        with open(output_path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f, delimiter=self.delimiter, quoting=self.quoting)
            
            headers = ["Target Host", "Detection Method", "Success", "MCP Detected",
                      "Transport Type", "Port", "Is Secure", "Risk Level"]
            writer.writerow(headers)
            
            for result in detection_results:
                server = result.mcp_server
                row = [
                    result.target_host,
                    result.detection_method.value,
                    result.success,
                    result.is_mcp_detected,
                    server.transport_type.value if server else "",
                    server.port if server else "",
                    server.is_secure if server else "",
                    result.risk_level
                ]
                writer.writerow(row)
    
    def _generate_assessment_results_file(self, assessment_results, output_path: Path) -> None:
        """Generate assessment results CSV file."""
        with open(output_path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f, delimiter=self.delimiter, quoting=self.quoting)
            
            headers = ["Target Host", "Risk Level", "Risk Score", "Total Findings",
                      "Critical Findings", "High Findings", "Total Vulnerabilities"]
            writer.writerow(headers)
            
            for result in assessment_results:
                row = [
                    result.target_host,
                    result.overall_risk_level.value,
                    f"{result.overall_risk_score:.2f}",
                    len(result.findings),
                    len(result.critical_findings),
                    len(result.high_findings),
                    len(result.vulnerabilities)
                ]
                writer.writerow(row) 